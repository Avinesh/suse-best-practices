:docinfo:

// = {title}
= MongoDB with SUSE Rancher: A Technical Quick Look

// SUSE Linux Enterprise Server 12 SP3 - SP5, SQL Server 2019
// :author: Samip Prikh
:revnumber: 0.0.1
:toc2:
:toc-title: MongoDB with SUSE Rancher A Technical Quick Look

:toclevels: 4

:sles: SUSE Linux Enterprise Server

== Motivation
Agility is the name of the game in modern application development.  This is driving the transformation of traditional development toward more agile methodologies, like DevOps, in which developers and operators work hand-in-hand to streamline the development-to-production workflow.  Underpinning this transformation is the move to microservices architectures, implemented with modern orchestration tools, like Kubernetes, that empower organizations to simplify their development and operations pipelines and accelerate their business goals.

The value of Kubernetes in a data solution lies in resilience and scalability.  Applications can be built with smaller, autonomous services focused on discrete, business-specific objectives or functions.  This makes it possible to scale data-aware software landscapes like never before and to create resilient structures to eliminate downtime and data loss.  Moreover, the modern, Kubernetes-powered, microservices architecture enables teams to focus on their own, discrete requirements while still integrating into the whole application stack.

SUSE Rancher gives organizations a robust, scalable, and efficient management platform to tame their entire Kubernetes landscape.  Deploying MongoDB with Rancher delivers highly available data services along with improved monitoring and management, resulting in optimizations across the organization.  Developers can focus on building data-rich applications that deliver innovative features to end-users and increase business value.  Operations can experience simplified management of robust, dynamic IT landscapes, which can span multiple sites and multiple geographic regions.  Business stakeholders can leverage these capabilities and efficiencies to accelerate business goals and gain market edge.

MongoDB offers a variety of compelling features additive to the SUSE Rancher Kubernetes management platform.  These include:

*Flexible Data Model:* MongoDB’s dynamic schema is ideal for handling changing requirements and continuous delivery.  You can seamlessly roll out new features without having to update existing records — a process that can take weeks for traditional, relational databases.  DevOps teams can quickly model data against an ever-changing environment and roll these changes into production, resulting in faster time to market and faster time to value.

*Resilience:* MongoDB’s replica sets have built-in redundancy, providing greater resilience and enhancing disaster recovery capabilities.  Administrators can even isolate operational workloads from analytical reporting in single database cluster to ensure sufficient resources are allocated to handle demand.

*Monitoring and Automation:*  Heterogenous services increase the level of complexity and can stall productivity. Technology that handles monitoring and automation is critical to keeping DevOps teams productive as their environments evolve. MongoDB Ops Manager features visualization, custom dashboards, and automated alerting.  It tracks, reports, processes, and visualizes 100+ key database and systems-health metrics, including operations counters, CPU utilization, replication status, and node status.

*Scalability:* MongoDB’s auto-sharding automatically partitions and distributes the database across nodes, serving IT infrastructures that require dynamic, high-performance capabilities.  Distribution can even span different geographic regions.  MongoDB is ideally suited to scale-out architectures.

All of this with SUSE, trusted by over two-thirds of Global Fortune 100 companies to deliver the open source, enterprise solutions that power their mission-critical operations.  With outstanding products and services from SUSE and partners, like MongoDB, our customers are empowered with the tools and support they need for success.


=== Technical Overview
SUSE Rancher is a lightweight Kubernetes installer that supports installation on bare-metal and virtualized servers.  Rancher solves a common issue in the Kubernetes community: installation complexity.  With Rancher, Kubernetes installation is simplified, regardless of what operating systems and platforms you are running.

This document reviews considerations for deploying and managing a highly available, MongoDB NoSQL database on a SUSE Rancher Kubernetes cluster.

In practice, the process is as follows:

* 1.Install a Kubernetes cluster through Rancher Kubernetes Engine
* 2.Install a cloud native storage solution on Kubernetes
* 3.Deploy https://docs.mongodb.com/kubernetes-operator/master/[MongoDB Enterprise Kubernetes Operator]
* 4.Configure a storage class and define storage requirements via Operator
* 5.Test failover by killing or cordoning nodes in your cluster


=== Setting up a cluster with SUSE Rancher

SUSE Rancher is a tool to install and configure Kubernetes in a choice of environments including bare metal, virtual machines, and IaaS. Rancher is a complete container management platform built on upstream Kubernetes.
It consists of three major components:
* A certified Kubernetes Distribution – Rancher Kubernetes Engine (RKE)
* A Kubernetes Management platform (Rancher)
* Application Catalog and management (Third-party)
Rancher has the capabilities to manage any Kubernetes cluster from a central location, via the
Rancher server.  As illustrated below, Rancher can manage any Kubernetes flavor and is not restricted to RKE.

INSERT IMAGES

For reference, see Rancher deployment guides for specific details on installation.    By the end of this step, you should have a cluster with one master and three worker nodes.

INSERT IMAGES

== Storage Considerations

When deploying an application that needs to retain data, you’ll need to create persistent storage. Persistent storage allows you to store application data external from the pod running your application. This storage practice allows you to maintain application data, even if the application’s pod fails.

A variety of storage options exist and can be used to create an HA data solution with Rancher.  Some considerations you may need to consider for your storage solution include:

* Volumes as persistent storage for the distributed stateful applications

* Partitioned block storage for Kubernetes volumes with or without a cloud provider

* Replicated block storage across multiple nodes and data centers to increase availability

* Secondary data backup storage (e.g., NFS or S3)

•	Cross-cluster disaster recovery volumes

•	Recurring volume snapshots

•	Recurring backups to secondary storage

•	Non-disruptive upgrades

Some common storage solutions to consider:

https://longhorn.io[Longhorn] - Distributed block storage system for Kubernetes. originally developed by Rancher Labs.  Currently sandbox project of the Cloud Native Computing Foundation

https://openebs.io[OpenEBS] – open source, CNCF Sandbox storage with flexible storage engine options - requires third-party integration

https://ceph.io[Ceph] – powerful, open source, general purpose storage in the CNCF Sandbox – requires third-party integration

https://portworx.com[Portworx] – proprietary solution with Rancher certified integration - installation steps can be found here

INSERT IMAGE HERE

=== Setting up your storage

Before proceeding, be sure that you understand the Kubernetes concepts of persistent volumes, persistent volume claims, and storage classes.  For more information, refer to https://rancher.com/docs/rancher/v2.x/en/cluster-admin/volumes-and-storage/how-storage-works[How Persistent Storage Works] in the Rancher documentation.

The workflow for setting up existing storage is as follows:
*1.	Ensure you have access to Set up your persistent storage. This may be storage in an infrastructure provider, or it could be your own storage.
*2.	Add a persistent volume (PV) that refers to the persistent storage.
*3.	Add a persistent volume claim (PVC) that refers to the PV.
*4.	Mount the PVC as a volume in your workload.

Visit the Rancher documentation section on https://rancher.com/docs/rancher/v2.x/en/cluster-admin/volumes-and-storage/attaching-existing-storage[Setting Up Existing Storage] for further details and prerequisites.

The overall workflow for provisioning new storage is as follows:
*1.	Add a StorageClass and configure it to use your storage provider. The StorageClass could refer to storage in an infrastructure provider, or it could refer to your own storage.
*2.	Add a persistent volume claim (PVC) that refers to the storage class.
*3.	Mount the PVC as a volume for your workload.

See https://rancher.com/docs/rancher/v2.x/en/cluster-admin/volumes-and-storage/provisioning-new-storage[Dynamically Provisioning New Storage in Rancher] for details and prerequisites.

=== Creating a storage class for MongoDB

Once the Kubernetes cluster is running and storage is configured, it is time to deploy a highly available MongoDB database.

MongoDB resources are created in Kubernetes as custom resources. After you create or update a MongoDB Kubernetes resource specification, you direct MongoDB Kubernetes Operator to apply this specification to your Kubernetes environment. Kubernetes Operator creates the defined StatefulSets, services and other Kubernetes resources. After the Operator finishes creating those objects, it updates the Ops Manager deployment configuration to reflect changes.

The following example shows a resource specification for a https://docs.mongodb.com/manual/reference/glossary/#term-replica-set[replica set] configuration

[source,bash]
----
apiVersion: mongodb.com/v1
kind: MongoDB
metadata:
  name: my-replica-set
spec:
  members: 3
  version: "4.2.2-ent"
  service: my-service
  opsManager: # Alias of cloudManager
    configMapRef:
      name: my-project
  credentials: my-credentials
  persistent: true
  type: ReplicaSet
  podSpec:
    cpu: "0.25"
    memory: "512M"
    persistence:
      multiple:
        data:
          storage: "10Gi"
        journal:
          storage: "1Gi"
          labelSelector:
            matchLabels:
              app: "my-app"
        logs:
          storage: "500M"
          storageClass: standard
    podAntiAffinityTopologyKey: nodeId
    podAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchExpressions:
          - key: security
            operator: In
            values:
            - S1
        topologyKey: failure-domain.beta.kubernetes.io/zone
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
        - matchExpressions:
          - key: kubernetes.io/e2e-az-name
            operator: In
            values:
            - e2e-az1
            - e2e-az2
    podTemplate:
      metadata:
        labels:
          label1: mycustomlabel
      spec:
        affinity:
          podAntiAffinity:
            preferredDuringSchedulingIgnoredDuringExecution:
              - podAffinityTerm:
                  topologyKey: "mykey"
                weight: 50
  security:
    tls:
      enabled: true
    authentication:
      enabled: true
      modes: ["X509"]
      internalCluster: "X509"
  additionalMongodConfig:
    net:
      ssl:
        mode: preferSSL
----

Full details can be found https://docs.mongodb.com/kubernetes-operator/master/reference/k8s-operator-specification[here].

=== Creating a Persistent Volume
We can now create a Persistent Volume Claim (PVC) based on the Storage Class. Dynamic provisioning will be created without explicitly provisioning a persistent volume (PV). As part of deployment, the Kubernetes Operator creates https://kubernetes.io/docs/concepts/storage/persistent-volumes[Persistent Volumes] for the Ops Manager StatefulSets. The Kubernetes container uses Persistent Volumes to maintain the cluster state between restarts.


=== Deploying MongoDB Operator on Kubernetes
Kubernetes needs help creating and managing stateful applications like databases.  The typical lifecycle events of a MongoDB cluster may include provisioning storage and computing power, configuring network connections, setting up users, and more.  This is where the MongoDB Enterprise Kubernetes Operator comes in.  It translates the human knowledge of how to create a MongoDB instance into a scalable, repeatable, and standardized methodology.  And it does this by using the built-in Kubernetes API and tools.
To use the operator, you simply need to provide it with the specifications for your MongoDB cluster.  The operator uses this information to direct Kubernetes into performing all the required steps to achieve the end state.

The general commands for deploying the MongoDB Enterprise Operator are:

[source,bash]
----
kubectl describe deployments mongodb-enterprise-operator -n <namespace>


helm install <chart-name> helm_chart \
     --values helm_chart/values.yaml \
----


The next step after deploying the operator is to create the database using a yaml file, such as:

[source,bash]
----
apiVersion: mongodb.com/v1
kind: MongoDB
metadata:

  name: <my-standalone>

spec:

  version: "4.2.2-ent"

  opsManager:
    configMapRef:

      name: <configMap.metadata.name>

            # Must match metadata.name in ConfigMap file

  credentials: <mycredentials>

  type: Standalone
  persistent: true
----

Now, we can deploy the database and check the status of the deployment with:
[source,bash]
----
kubectl apply -f <standalone-conf>.yaml

kubectl get mdb <resource-name> -o yaml
----

At this point, MongoDB has been deployed via the operator.  Additional settings can be applied to create https://docs.mongodb.com/kubernetes-operator/stable/tutorial/deploy-replica-set/[replica] sets to further enhance data availability.  Also, sharded clusters can be created to ena-ble greater throughput across a distributed system.

Additionally, see specific https://github.com/mongodb/mongodb-enterprise-kubernetes[documentation] and steps for full installation and configuration options.

=== Server registration

To gain access to SUSE repositories, you first need to register your server with `SUSEConnect`. If you are launching an On-Demand (or Pay-As-You-Go)
instance and not a BYOS (Bring Your Own Subscription) instance at a public cloud provider, skip this step.

[source,bash]
----
sudo SUSEConnect --regcode ${REGISTRATION_CODE} --email ${EMAIL_ADDRESS}
----


Alternatively, if you have a

* SUSE https://documentation.suse.com/sles/12-SP5/single-html/SLES-smt/#book-smt[SMT] (Subscription Management Tool)
* or SUSE https://documentation.suse.com/sles/15-SP2/single-html/SLES-rmt/#book-rmt[RMT] (Repository Mirroring Tool)
* or https://documentation.suse.com/external-tree/en-us/suma/4.1/suse-manager/index.html[SUSE Manager]

server you want to use, use the `--url` option instead.

[source,bash]
----
sudo SUSEConnect --url ${REGISTRATION_SERVER_URL}
----

More information about registering can be found in the https://documentation.suse.com/sles/12-SP5/html/SLES-all/cha-y2-sw.html#sec-y2-sw-register-suseconnect[{sles} 12 SP5 Deployment Guide].


=== Repositories

To verify packages from Microsoft’s SQL Server repositories, first add their package signing key:

[source,bash]
----
sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc
----


Then add the repository. The `refresh` option enables auto refresh of the repository and the `check` option validates the URL:

[source,bash]
----
sudo zypper addrepo --refresh --check https://packages.microsoft.com/config/sles/12/mssql-server-2019.repo
----


=== Package

To install the SQL Server package non-interactively, run the following command:

[source,bash]
----
sudo zypper install --no-confirm mssql-server
----

== Configuration

=== Initial configuration

To configure and start SQL Server, `mssql-conf` can be used to accept the EULA, set the SQL Server Edition, and the SA password.

[TIP]
--
For convenience, you can add the configuration to your `PATH` to avoid typing the full path each time:

[source,bash]
----
echo 'export PATH="$PATH:/opt/mssql/bin"' >> ~/.bashrc
source ~/.bashrc
----

--

Then, to configure and start `msql-server` (`mssql-conf` starts the `msql-server` immediately after configuring),
run the following command:

[source,bash]
----
sudo ACCEPT_EULA='Y' MSSQL_SA_PASSWORD=Suselove12 MSSQL_PID='Developer' mssql-conf --noprompt setup
----

* `ACCEPT_EULA` accepts the SQL Server EULA
* `MSQL_SA_PASSWORD` sets the SA user password. Ensure password requirements as outlined in <<password_requirements>> are followed.
* `MSQL_PID` sets the SQL Server edition, acceptable values are:
** Evaluation
** Developer
** Express
** Web
** Standard
** Enterprise
** Product key formatted as +#####-#####-#####-#####-#####+
* The `noprompt` option configures SQL Server non-interactively

WARNING: It is recommended to change the SA password later with `mssql-conf set-sa-password`
or disable the history prior to configuring SQL Server with `set +o history`, and re-enabling it afterward with `set -o history` (Bash).

SQL Server should be started at this point. You can verify this with `netcat`.
SQL Server listens for connections on port `1433` by default:

[source,bash]
----
sudo zypper install --no-confirm netcat
nc -vz localhost 1433
----

For further configuration, use `mssql-conf` to set additional parameters. Changes will take effect after a restart:

[source,bash]
----
sudo mssql-conf set ${parameter}
sudo systemctl restart mssql-server
----

Available `mssql-conf` options are described in https://docs.microsoft.com/en-us/sql/linux/sql-server-linux-configure-mssql-conf[Configure SQL Server on Linux with the mssql-conf tool].

An alternative way to configure SQL Server is using the `/var/opt/mssql/mssql.conf` file.
Settings are stored in the https://en.wikipedia.org/wiki/INI_file[INI] format.

A sample `mssql.conf` file is shown below. Edit the `mssql.conf` file and restart `mssql-server` to apply changes.

[source,ini]
----
[EULA]
accepteula = Y

[filelocation]
defaultdatadir = /var/opt/mssql/data/
defaultdumpdir = /var/opt/mssql/data/
defaultlogdir = /var/opt/mssql/data/

[network]
tcpport = 1433

[sqlagent]
enabled = true
----

== Tools

Now that SQL Server is running, you can query it. The `mssql-tools` package includes `sqlcmd`, which is a shell to query SQL Server.
Install it similarly to the `mssql-server` package.

Add the repository:

[source,bash]
----
sudo zypper addrepo --refresh --check https://packages.microsoft.com/config/sles/12/prod.repo
----

Install the `mssql-tools` package:

[source,bash]
----
sudo ACCEPT_EULA=Y zypper install --no-confirm mssql-tools
----

[TIP]
--
You can add the tools to your `PATH` like you did for `mssql-conf`:

[source,bash]
----
echo 'export PATH="$PATH:/opt/mssql-tools/bin"' >> ~/.bashrc
source ~/.bashrc
----

Alternatively, you can symlink `sqlcmd` to `/usr/local/bin/` since it is a binary:

[source,bash]
----
sudo ln --symbolic /opt/mssql-tools/bin/sqlcmd /usr/local/bin/sqlcmd
----

--

Then start `sqlcmd` and input a query. The `-S` option designates the server. The `-U` option specifies the user.
Available options can be found at https://docs.microsoft.com/en-us/sql/tools/sqlcmd-utility?view=sql-server-ver15#syntax[sqlcmd Utility Syntax].


[source,bash]
----
sudo sqlcmd -S localhost -U SA
----

[source,sql]
----
SELECT name from sys.databases
GO

name
master
tempdb
model
msdb
TestDB
----


`GO` is required here to execute the previous statements.

To exit `sqlcmd`, input `quit`:


[source,sql]
----
quit
----


The full `sqlcmd` documentation can be found at https://docs.microsoft.com/en-us/sql/tools/sqlcmd-utility?view=sql-server-ver15[sqlcmd Utility].


== Administration

=== `systemd`

The `mssql-server` package installs and configures SQL Server as a https://systemd.io/[`systemd`] service.
`systemd` provides a framework for managing services, mounts, and system states.
You can find more details about `systemd` unit files at https://www.freedesktop.org/software/systemd/man/systemd.unit.html[systemd.unit — Unit configuration].
To control the `mssql-server` service, use `systemctl` to retrieve the `status`, `start`, `stop`, `restart`, `enable`, and `disable` the service.

* Display `mssql-server` status:
+
[source,bash]
----
sudo systemctl status mssql-server

● mssql-server.service - Microsoft SQL Server Database Engine
   Loaded: loaded (/usr/lib/systemd/system/mssql-server.service; enabled; vendor preset: disabled)
   Active: active (running) since Thu 2021-02-25 01:54:18 UTC; 16h ago
     Docs: https://docs.microsoft.com/en-us/sql/linux
 Main PID: 1341 (sqlservr)
    Tasks: 166
   CGroup: /system.slice/mssql-server.service
           ├─1341 /opt/mssql/bin/sqlservr
           └─1596 /opt/mssql/bin/sqlservr
----

* Start `mssql-server`:
+
[source,bash]
----
sudo systemctl start mssql-server
----

* Stop `mssql-server`:
+
[source,bash]
----
sudo systemctl stop mssql-server
----

* Restart `mssql-server`:
+
[source,bash]
----
sudo systemctl restart mssql-server
----

* Enable `mssql-server` to start on boot (`mssql-server` is enabled by default on installation):
+
[source,bash]
----
sudo systemctl enable mssql-server

Created symlink from /etc/systemd/system/multi-user.target.wants/mssql-server.service to /usr/lib/systemd/system/mssql-server.service.
----

* Disable `mssql-server` to present starting on boot:
+
[source,bash]
----
sudo systemctl disable mssql-server

Removed symlink /etc/systemd/system/multi-user.target.wants/mssql-server.service.
----

=== Logs

For troubleshooting, the logs and crash dumps are written to `/var/opt/mssql/log` by default.
Notable logs are the *errorlogs* (+errorlog*+), *trace logs* (+*.trc+), *sqlagent logs* (+sqlagent*+),
and the *extended events logs* (*.xel). Core dumps are written with the `.tar.gz2` extension and SQL dumps with the `.mdmp` extension.
To view these resources, you need `root` or the `mssql` user access.

[source,bash]
----
ls /var/opt/mssql/log
HkEngineEventFile_0_132574672188100000.xel	errorlog	errorlog.4	log_20.trc	sqlagent.2  		system_health_0_132574672201000000.xel
HkEngineEventFile_0_132574672310500000.xel	errorlog.1	health.log	log_21.trc	sqlagent.3		system_health_0_132574672319150000.xel
HkEngineEventFile_0_132575629019340000.xel	errorlog.2	log_18.trc	log_22.trc	sqlagent.out		system_health_0_132575629028000000.xel
HkEngineEventFile_0_132575645400520000.xel	errorlog.3	log_19.trc	sqlagent.1	sqlagentstartup.log	system_health_0_132575645408320000.xel
----

=== Loading sample data

Microsoft has provided some https://github.com/microsoft/sql-server-samples[sample databases]
you can use to seed your `mssql-server` instance with some data.

Here is an example of loading our SQL server instance with the sample database `WideWorldImporters`.

Download the `WideWorldImporters` database:

[source,bash]
----
curl --location https://github.com/Microsoft/sql-server-samples/releases/download/wide-world-importers-v1.0/WideWorldImporters-Full.bak \
    --output /tmp/WideWorldImporters-Full.bak
----

Restore full backup into `mssql-server` with `sqlcmd` while updating paths for the data, userdata, transaction log, and in-memory data:

[source,sql]
----
sqlcmd -S localhost \
    -U sa \
    -P Suselove12 \
    -Q "RESTORE DATABASE WideWorldImporters \
        FROM DISK ='/tmp/WideWorldImporters-Full.bak' WITH \
        MOVE 'WWI_Primary' TO '/var/opt/mssql/data/WideWorldImporters.mdf', \
        MOVE 'WWI_UserData' TO '/var/opt/mssql/data/WideWorldImporters_UserData.ndf', \
        MOVE 'WWI_Log' TO '/var/opt/mssql/data/WideWorldImporters.ldf', \
        MOVE 'WWI_InMemory_Data_1' TO '/var/opt/mssql/data/WideWorldImporters_InMemory_Data_1'"

Processed 1464 pages for database 'WideWorldImporters', file 'WWI_Primary' on file 1.
Processed 53096 pages for database 'WideWorldImporters', file 'WWI_UserData' on file 1.
Processed 33 pages for database 'WideWorldImporters', file 'WWI_Log' on file 1.
Processed 3862 pages for database 'WideWorldImporters', file 'WWI_InMemory_Data_1' on file 1.
Converting database 'WideWorldImporters' from version 852 to the current version 904.
Database 'WideWorldImporters' running the upgrade step from version 852 to version 853.
Database 'WideWorldImporters' running the upgrade step from version 853 to version 854.
...
Database 'WideWorldImporters' running the upgrade step from version 902 to version 903.
Database 'WideWorldImporters' running the upgrade step from version 903 to version 904.
RESTORE DATABASE successfully processed 58455 pages in 37.388 seconds (12.214 MB/sec).
----

When loaded, project ten table names from the `WideWorldImporters` database to test it out:

[source,sql]
----
sqlcmd -S localhost \
    -U sa \
    -P Suselove12 \
    -Q "SELECT TOP(10) table_name FROM \
        WideWorldImporters.information_schema.tables \
        WHERE table_type = 'BASE TABLE'"

table_name
--------------------------------------------------------------------------------------------------------------------------------

Colors
Colors_Archive
OrderLines
PackageTypes
PackageTypes_Archive
StockGroups
StockItemStockGroups
StockGroups_Archive
StateProvinces
CustomerTransactions

(10 rows affected)
----

== Summary

Businesses around the world look to SUSE to help them simplify and optimize their IT environments,
modernize their applications and infrastructure, and accelerate innovation on-premises, in the cloud, and at the edge.
With {sles} support for Microsoft SQL Server, businesses can streamline their IT landscape and operations
without changing their preferred enterprise database management system.

At this point, you should have a rudimentary understanding of how to install SQL Server on {sles},
install SQL Server tools, query SQL Server and perform basic administration.
To stay up to date on the latest SQL Server on Linux features bookmark https://docs.microsoft.com/en-us/sql/linux/sql-server-linux-release-notes-2019?view=sql-server-ver15[Release notes for SQL Server 2019 on Linux].


== Appendix

[id="password_requirements"]
=== SQL Server password requirements

SQL Server passwords must be between 8 and 128 (inclusive), cannot contain Unicode control characters `[Ll, Lu, Nd, Cc]`
and must contain at least three of the following:

* Uppercase letters
* Lowercase letters
* Numbers
* Symbols from the set ``(`~!@#$%^&*_-+=|\\{}[]:;\"'<>,.?)/``

=== References

* https://documentation.suse.com/sles/12-SP5/[SUSE Linux Enterprise Server 12 SP5]
* https://documentation.suse.com/external-tree/en-us/suma/4.1/suse-manager/index.html[SUSE Manager 4.1 Documentation]
* https://documentation.suse.com/sles/12-SP5/single-html/SLES-smt/#book-smt[Subscription Management Tool Guide]
* https://documentation.suse.com/sles/15-SP2/single-html/SLES-rmt/#book-rmt[Repository Mirroring Tool Guide]
* https://www.suse.com/support/kb/doc/?id=000019401[How to register a SLE system against a SMT server]
* https://www.suse.com/campaign/sql-server-on-linux/[The Power of SQL Server on Linux]
* https://docs.microsoft.com/en-us/sql/linux/sql-server-linux-setup?view=sql-server-ver15[Installation guidance for SQL Server on Linux]
* https://docs.microsoft.com/en-us/sql/linux/quickstart-install-connect-suse?view=sql-server-ver15[Quickstart: Install SQL Server and create a database on SUSE Linux Enterprise Server]
* https://docs.microsoft.com/en-us/sql/linux/sql-server-linux-configure-mssql-conf?view=sql-server-ver15[Configure SQL Server on Linux with the mssql-conf tool]
* https://docs.microsoft.com/en-us/sql/tools/sqlcmd-utility?view=sql-server-ver15[sqlcmd Utility]
* https://www.suse.com/lp/geek-guide-sql-server-on-suse[Modernizing with SQL Server on Linux for a Cloud Native World]
* https://github.com/microsoft/sql-server-samples[sql-server-samples]


:leveloffset: 0
// Standard SUSE Best Practices includes
== Legal notice
include::common_sbp_legal_notice.adoc[]

++++
<?pdfpagebreak?>
++++

// Standard SUSE Best Practices includes
// include::common_gfdl1.2_i.adoc[]

:leveloffset: 0
include::common_gfdl1.2_i.adoc[]
